#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h> /* définit mmap  */
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main (int argc, char *argv[])
{
 int fin, fout, taille;
 char *src, *dst;
 char qq [1];
 struct stat statbuf;
src=argv[1];
dst=argv[1];

 if (argc != 3) {
   printf("usage: %s <fichier source> <fichier destination>\n", argv[0]);
   exit(1);
 }
 /* ouvrir source */
int fs=open(src,O_CREAT|O_TRUNC|O_RDWR);
if (fs < 0) {
    printf("Erreur ouverture") ;
    exit(1) ;
     }
	
 /* recuperer la taille de la source */
 int taille_src=fstat(*src);

 /* coupler source */
 char *buf=mmap(fs,taille_src,PROT_READ|PROT_WRITE,MAP_ANON|MAP_SHARED,-1,0);


 /* ouvrir destination */
int fd=open(dst,O_CREAT|O_TRUNC|O_RDWR);
 if (fd < 0) {
    printf("Erreur ouverture") ;
    exit(1) ;
     }
	
 /*	Note : le mode O_RDWR (plutôt que O_WRONLY) est nécessaire car mmap impose 
 	qu'un fichier couplé soit toujours (au moins) ouvert en lecture
 */

 /* ajuster la taille du fichier destination à la taille du fichier source */
  lseek(fd, taille_src,0 );

 /*	Note : 
 	Pourquoi ajuster ? 
 	------------------
 	mmap ne spécifie pas quel est le resultat d'une ecriture *apres* la fin d'un fichier
	couplé (SIGBUS est une possibilite, frequente). Il faut donc fixer la taille du 
	fichier destination à la taille du fichier source *avant* le couplage.
	Comment ajuster ?
	-----------------
	 Le plus simple est d'utiliser truncate, 
	 mais vous pouvez utiliser lseek(a la taille du fichier source) + write d'un octet, 
	 que vous connaissez déjà 
 */
 	
 /* coupler destination */
 char *buf=mmap(fd,fstat(*dst),PROT_READ|PROT_WRITE,MAP_ANON|MAP_SHARED,-1,0);
 
 /* Note : MAP_SHARED est necessaire pour que les ecritures soient visibles 
 	dans le fichier */

 /* la copie est le plus facile :) */
 memcpy(*src,*dst,fstat(*src));

 exit(0);
}