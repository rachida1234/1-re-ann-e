#include <unistd.h>  /*Importation des bibliotheques nécessaires*/
#include <string.h>    
#include <stdbool.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>  /*pour la gestion des signaux*/
#include <sys/stat.h>
#include <sys/wait.h> 
#include <stdio.h>
#include "readcmd.h" /*permet de manipuler une ligne de commande.*/

enum Status {
     ACTIF_FG, SUSPENDU, ACTIF_BG /*Les statuss  d'un processus*/
};
typedef enum Status T_Status;

typedef struct {
       int id;/*Identifiant du processus propre au minishell*/
       pid_t pid;
       char *ligneCmd; /*La ligne de commande lancée*/
       T_Status status;
} Job;

typedef struct {
        int Max; /*max des id*/ 
        int K; /*nombre de fils crées*/
        Job list[];      
} listJobs;

/*Pid du processus en avant-plan */
pid_t pid_fg;
/*Déclaration de listeJobs*/
listJobs listeJobs;


/* la commande 'lj' permet de lister tous les processus lancés depuis le shell*/
void lj() {
    if (listeJobs.K >= 1) {
       for (int j =0; j< listeJobs.K; j++) {
            if (listeJobs.list[j].status == ACTIF_FG){
                printf("[%d]     pid: %d     Actif(FG)     %s \n" ,listeJobs.list[j].id ,listeJobs.list[j].pid, listeJobs.list[j].ligneCmd);
                fflush(stdout);
            
            } else if (listeJobs.list[j].status == ACTIF_BG){
                printf("[%d]     pid: %d     Actif(BG)    %s \n" ,listeJobs.list[j].id ,listeJobs.list[j].pid, listeJobs.list[j].ligneCmd);
                fflush(stdout);
            } else {
                printf("[%d]     pid: %d     Suspendu     %s \n" ,listeJobs.list[j].id ,listeJobs.list[j].pid, listeJobs.list[j].ligneCmd);
                fflush(stdout);
            }
        }
    }
}
/*Chercher le max des ids*/
int Max(){
  int max=listeJobs.list[0].id;
  for (int j=1; j< listeJobs.K; j++) {
        if (listeJobs.list[j].id > max) {
            max=listeJobs.list[j].id;
        }
        }
    return max;
}
/*Supprimer un processus de la liste des jobs*/
void deleteJob(pid_t pid_fg){
    for (int j=0; j< listeJobs.K; j++) {
        if (listeJobs.list[j].id == pid_fg) {
            for (int i= j; i< listeJobs.K; i++) {
            listeJobs.list[i] = listeJobs.list[i + 1];
        }
         listeJobs.Max=Max();
         listeJobs.K--;
        }
    }
}

/*Ajouter un nouveau job à listeJobs*/
void addJob(int fils, char* commande, T_Status status) {
    listeJobs.list[listeJobs.K].pid = fils;
    listeJobs.list[listeJobs.K].id = listeJobs.Max +1;
    
    char *ligne_commande = malloc(20*sizeof(char));
    strcpy(ligne_commande, commande);
    listeJobs.list[listeJobs.K].ligneCmd = ligne_commande;
    listeJobs.list[listeJobs.K].status = status;
    listeJobs.Max =Max();
    listeJobs.K++ ;
}

/*retourner le pid d'un Job dans listJobs à partir de son id*/
int getPid(int id) {
    for (int j=0; j< listeJobs.K; j++) {
        if (listeJobs.list[j].id == id) {
            return listeJobs.list[j].pid;   
        }
    }
    return -1;
}
/*retourner l'indice d'un Job dans listJobs à partir de son pid*/
int getIndice(pid_t Pid) {
    for (int j=0; j<= listeJobs.K; j++) {
        if (listeJobs.list[j].pid == Pid) {
            return j;   
        }
    }
    return -1;
}
/* la commande 'stop' permet de suspendre un job */
void stop ( char ** cmd) {
    
    /*Si l'id fourni à sj n'est pas valide*/
     if (getPid(atoi(cmd[1])) == -1| atoi(cmd[1]) >listeJobs.Max){
          printf("stop : identifiant fourni inexistant \n");
    }else if (cmd[1]==0){
        printf("utilisation : stop [identifiant du processus >=1] .\n");
    } else {
        int pid = getPid(atoi(cmd[1]));
        kill(pid, SIGSTOP);
        listeJobs.list[getIndice(pid)].status = SUSPENDU;
    }
}

/* la commande 'bg' permet de reprendre en arrière plan un job suspendu*/
void BG ( char ** cmd) {
    
    /*Si l'id fourni à BG n'existe pas*/
     if (getPid(atoi(cmd[1])) == -1| atoi(cmd[1]) >listeJobs.Max){
          printf("identifiant fourni inexistant! \n");
          
    } else if (cmd[1]==0) {/*la commande 'bg' n'est pas suivi de l'id du Job*/
          printf("utilisation : bg [identifiant du processus >=1] .\n");
    } else {
        /*reprendre le processus en arrière plan*/
        int pid = getPid(atoi(cmd[1]));
        kill(pid, SIGCONT);
        listeJobs.list[getIndice(pid)].status = ACTIF_BG;
    }
}

/* la commande 'fg' permet de poursuivre en avant plan un job suspendu ou en arrière plan*/
void FG ( char ** cmd) {
    
    /*Si l'id fourni à FG n'existe pas*/
     if (getPid(atoi(cmd[1])) == -1| atoi(cmd[1]) >listeJobs.Max){
          printf("identifiant fourni inexistant ! \n");
          
    } else if (cmd[1]==0) {/*la commande 'fg' n'est pas suivi de l'id du Job*/
          printf("utilisation : fg [identifiant du processus >=1] .\n");
    } else {
        int pid = getPid(atoi(cmd[1]));
        kill(pid, SIGCONT);
        waitpid (pid , 0, 0);
        listeJobs.list[getIndice(pid)].status = ACTIF_FG;
    }
}

/*Traitant du signal SIGINT (ctrl-c)*/
void handlerSIGINT(int signal) {    
   kill(SIGINT, pid_fg);
   deleteJob(pid_fg);
}

/*Traitant du signal SIGCHLD */
void handlerSIGCHLD(int signal) { 
    int status_fils;
    pid_t pid_fils;
    do {
        pid_fils = waitpid(-1, &status_fils, WNOHANG | WUNTRACED | WCONTINUED);
        if ((pid_fils == -1)) {
            perror("erreur de waitpid");
            exit(EXIT_FAILURE);
        } else if (pid_fils > 0) {
           int a=getIndice(pid_fils);
            if (a!=-1) {
                if (WIFSTOPPED(status_fils)) {
                   listeJobs.list[a].status = SUSPENDU;
                } else if (WIFEXITED(status_fils)) {
                   deleteJob(pid_fils);
                } else if (WIFCONTINUED(status_fils)) {
                   listeJobs.list[a].status = ACTIF_FG;
                } 
            }
        }
    } while (pid_fils > 0);
}
/*************Main************/
int main(int argc, char *argv[]) {
    pid_t fils;
    struct cmdline *cmd;
    char cwd[200];
    int wstatus;
    int FilsTermine;
    
    while(1) {                 
         do {
            getcwd(cwd,sizeof(cwd)); //Récuperer le nom du répértoire du travail courant
            printf("~/%s$",cwd);
            cmd=readcmd();
            signal(SIGINT, handlerSIGINT);
            signal(SIGTSTP,SIG_IGN);
         }while(cmd->seq[0] == NULL);
         /***Question 4&6**/
         /*La commande interne "exit"*/
          if (!strcmp(cmd->seq[0][0], "exit")) {
                exit(1);
            }
          /*La commande interne "cd"*/
          if (!strcmp(cmd->seq[0][0],"cd")) {
                 if (!strcmp(cmd->seq[0][1],"~")|| cmd->seq[0][1]==NULL) {
                         chdir(getenv("HOME"));

                  } else if (chdir(cmd->seq[0][1])==-1) {
                     printf("cd : %s : pas de fichier ou dossier de ce type.\n", cmd->seq[0][1]);
                 }
                 else{
                    /*si chdir(cmd->seq[0][1])==0*/
                     chdir(cmd->seq[0][1]);
                 }
            }
           /* La commande lancée est  'bg id' */
            else if (!strcmp(cmd->seq[0][0], "bg")) {
                BG(cmd->seq[0]);
            }
            /* La commande lancée est 'fg id' */
            else if (!strcmp(cmd->seq[0][0], "fg")) {
                FG(cmd->seq[0]);
            }
            /* La commande lancée est 'stop id'*/ 
            else if (!strcmp(cmd->seq[0][0], "sj")) {
                stop(cmd->seq[0]);
            }
             /* La commande lancée est 'lj'*/ 
            else if (!strcmp(cmd->seq[0][0], "lj")) {
                lj();
            }
            
           else if (cmd->seq[1] == NULL) {
           fils = fork();
           if (fils == 0) {
            /*Pour lancer les commandes en tache de fond on remplace execlp par execvp*/
             if (execv(cmd->seq[0][0],cmd->seq[0])>0){;
                 exit(EXIT_SUCCESS);
             }else {
                perror("Commande non reconnue");
                exit(EXIT_FAILURE);
              }
           }
           if (fils ==-1) {
            printf("Erreur dans le fork \n");
            exit(1);
           }
           else {
                if (cmd->backgrounded == NULL){
                        /* Enregistrement du processus fils dans listeJobs*/
                        addJob(fils, *cmd->seq[0], ACTIF_FG);
                        pid_fg = fils;
                        waitpid(fils,&wstatus,WUNTRACED);
                        /*supprimer le processus car son traitement est achevé.*/
                        if (!WIFSTOPPED(wstatus)) {
                              deleteJob(fils);
                        }
                        
                        
                } else {
                        /* Enregistrement du processus fils dans listeJobs*/
                        addJob(fils, *cmd->seq[0], ACTIF_BG);
                    }
                }
            
          }
    }
}



